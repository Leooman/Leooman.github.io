import{_ as t,c as d,o as r,a as e}from"./app.04bd075c.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"创建型设计模式","slug":"创建型设计模式","link":"#创建型设计模式","children":[]},{"level":2,"title":"结构型设计模式","slug":"结构型设计模式","link":"#结构型设计模式","children":[]},{"level":2,"title":"行为型设计模式","slug":"行为型设计模式","link":"#行为型设计模式","children":[]}],"relativePath":"designPattern/index.md"}'),a={name:"designPattern/index.md"},i=e('<h2 id="创建型设计模式" tabindex="-1">创建型设计模式 <a class="header-anchor" href="#创建型设计模式" aria-hidden="true">#</a></h2><p>创建型设计模式关注于对象创建的机制方法，通过该方法，对象以适应工作环境的方式被创建</p><p>基本的对象创建方法可能会给项目增加额外的复杂性，而这些模式的目的就是为了通过控制创建过程解决这个问题</p><p>包含工厂模式（Factory）、抽象工厂模式 （Abstract）、原型模式 （Prototype）、单例模式 （Singleton）以及 建造者模式（Builder）</p><h2 id="结构型设计模式" tabindex="-1">结构型设计模式 <a class="header-anchor" href="#结构型设计模式" aria-hidden="true">#</a></h2><p>结构型模式关注于对象组成和通常识别的方式实现不同对象之间的关系</p><p>该模式有助于在系统的某一部分发生改变的时候，整个系统结构不需要改变</p><p>该模式同样有助于对系统中没有达到某一目的的部分进行重组</p><p>包含适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</p><h2 id="行为型设计模式" tabindex="-1">行为型设计模式 <a class="header-anchor" href="#行为型设计模式" aria-hidden="true">#</a></h2><p>行为型模式关注改善或精简在系统中不同对象间通信</p><p>包含策略模式、模板方法模式、观察者模式、迭代模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</p><table><thead><tr><th>设计模式类型</th><th>模式</th><th>模式描述</th></tr></thead><tbody><tr><td>Creational创建型：根据创建对象的概念</td><td>Factory Method(工厂方法)</td><td>通过将数据和事件接口化来构建若干个子类</td></tr><tr><td></td><td>Abstract Factory(抽象工厂)</td><td>建立若干族类的一个实例，这个实例不需要具体类的细节信息。（抽象类）</td></tr><tr><td></td><td>Builder (建造者)</td><td>将对象的构建方法和其表现形式分离开来，总是构建相同类型的对象</td></tr><tr><td></td><td>Prototype(原型)</td><td>一个完全初始化的实例，用于拷贝或者克隆</td></tr><tr><td></td><td>Singleton(单例)</td><td>一个类只有唯一的一个实例，这个实例在整个程序中有一个全局的访问点</td></tr><tr><td>Structural结构型：根据构建对象块的方法</td><td>Adapter(适配器)</td><td>将不同类的接口进行匹配，调整，这样尽管内部接口不兼容但是不同的类还是可以协同工作的</td></tr><tr><td></td><td>Bridge(桥接模式)</td><td>将对象的接口从其实现中分离出来，这样对象的实现和接口可以独立的变化</td></tr><tr><td></td><td>Composite(组合模式)</td><td>通过将简单可组合的对象组合起来，构成一个完整的对象，这个对象的能力将会超过这些组成部分的能力的总和，即会有新的能力产生</td></tr><tr><td></td><td>Decorator(装饰器)</td><td>动态给对象增加一些可替换的处理流程</td></tr><tr><td></td><td>Facada(外观模式)</td><td>一个类隐藏了内部子系统的复杂度，只暴露出一些简单的接口</td></tr><tr><td></td><td>Flyweight(享元模式)</td><td>一个细粒度对象，用于将包含在其它地方的信息 在不同对象之间高效地共享</td></tr><tr><td></td><td>Proxy(代理模式)</td><td>一个充当占位符的对象用来代表一个真实的对象</td></tr><tr><td>Behavioral行为型：基于对象间作用方式</td><td>Interpreter(解释器)</td><td>将语言元素包含在一个应用中的一种方式，用于匹配目标语言的语法</td></tr><tr><td></td><td>Template Method(模板方法)</td><td>在一个方法中为某个算法建立一层外壳，将算法的具体步骤交付给子类去做</td></tr><tr><td></td><td>Chain of Responsibility(响应链)</td><td>一种将请求在一串对象中传递的方式，寻找可以处理这个请求的对象</td></tr><tr><td></td><td>Command(命令)</td><td>封装命令请求为一个对象，从而使记录日志，队列缓存请求，未处理请求进行错误处理 这些功能称为可能</td></tr><tr><td></td><td>Iterator(迭代器)</td><td>在不需要直到集合内部工作原理的情况下，顺序访问一个集合里面的元素</td></tr><tr><td></td><td>Mediator(中介者模式)</td><td>在类之间定义简化的通信方式，用于避免类之间显式的持有彼此的引用</td></tr><tr><td></td><td>Observer(观察者模式)</td><td>用于将变化通知给多个类的方式，可以保证类之间的一致性</td></tr><tr><td></td><td>State(状态)</td><td>当对象状态改变时，改变对象的行为</td></tr><tr><td></td><td>Strategy(策略)</td><td>将算法封装到类中，将选择和实现分离开来</td></tr><tr><td></td><td>Visitor(访问者)</td><td>为类增加新的操作而不改变类本身</td></tr></tbody></table>',13),o=[i];function n(l,h,s,c,p,_){return r(),d("div",null,o)}const b=t(a,[["render",n]]);export{m as __pageData,b as default};
